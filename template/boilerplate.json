[
    "\"\"\"",
    "File: <<filename>>",
    "Author: <<author>>",
    "Created: <<dateformat('dddd MMMM Do YYYY HH:mm:ss')>>",
    "\"\"\"",
    "",
    "import math",
    "import sys",
    "",
    "# sys.setrecursionlimit(10**6)",
    "",
    "inf = math.inf",
    "eps = 1e-9",
    "mod = 10**9 + 7",
    "# mod = 998244353",
    "",
    "std_in, basic, search_sort, packages = 1, 1, 1, 1",
    "out_tog = 0",
    "graph = 0",
    "hashing = 0",
    "rof = 0",
    "de = 0",
    "",
    "",
    "if True:",
    "    if std_in:",
    "        _input = input  # Display prompt to stdout",
    "        input = lambda: sys.stdin.readline().rstrip()",
    "",
    "        def intput():",
    "            return sys.stdin.readline()",
    "",
    "        def printf(tbp: list[str]):",
    "            sys.stdout.write(\"\\n\".join(tbp) + \"\\n\")",
    "",
    "        def sprint(op: list[str]):",
    "            sys.stdout.write(\" \".join(op) + \"\\n\")",
    "",
    "        def iprint(arr: list[int]):",
    "            sys.stdout.write(\"\\n\".join(map(str, arr)) + \"\\n\")",
    "",
    "        def I():",
    "            return input()",
    "",
    "        def II():",
    "            return int(intput())",
    "",
    "        def MII():",
    "            return map(int, intput().split())",
    "",
    "        def LI():",
    "            return list(input())",
    "",
    "        def LII():",
    "            return list(map(int, intput().split()))",
    "",
    "        def LFI():",
    "            return list(map(float, input().split()))",
    "",
    "        # Graph 1-indexing -> list 0-idx",
    "        def GMI():",
    "            return map(lambda x: int(x) - 1, intput().split())",
    "",
    "        def LGMI():",
    "            return list(map(lambda x: int(x) - 1, intput().split()))",
    "",
    "    if basic:",
    "",
    "        class Lrap(list):",
    "            def find(self, tg):",
    "                try:",
    "                    return self.index(tg)",
    "                except ValueError:",
    "                    return -1",
    "",
    "        def exp(x, n, m=None):",
    "            modular = m is not None",
    "            if modular:",
    "                x %= m",
    "            res = 1",
    "",
    "            while n:",
    "                if n % 2:",
    "                    res = res * x",
    "                    if modular:",
    "                        res %= m",
    "",
    "                x = x * x",
    "                if modular:",
    "                    x %= m",
    "                n //= 2",
    "",
    "            return res",
    "",
    "        def fmax(x, y):",
    "            return x if x > y else y",
    "",
    "        def fmin(x, y):",
    "            return x if x < y else y",
    "",
    "        def feq(x: float, y: float):",
    "            return abs(x - y) <= max(eps * max(abs(x), abs(y)), eps)",
    "",
    "        def nprime(n: int):",
    "            if n <= 1:",
    "                return False",
    "            if n % 2 == 0:",
    "                return n == 2",
    "",
    "            max_div = math.ceil(math.sqrt(n))",
    "            for i in range(3, max_div, 2):",
    "                if n % i == 0:",
    "                    return False",
    "            return True",
    "",
    "        def allprime(n):",
    "            prime = [True for _ in range(n + 1)]",
    "            p = 2",
    "",
    "            while p * p <= n:",
    "                if prime[p]:",
    "                    for i in range(p * p, n + 1, p):",
    "                        prime[i] = False",
    "                p += 1",
    "            c = 0",
    "",
    "            for p in range(2, n):",
    "                if prime[p]:",
    "                    c += 1",
    "            return c",
    "",
    "        PRIMES = [",
    "            2,",
    "            3,",
    "            5,",
    "            7,",
    "            11,",
    "            13,",
    "            17,",
    "            19,",
    "            23,",
    "            29,",
    "            31,",
    "            37,",
    "            41,",
    "            43,",
    "            47,",
    "            53,",
    "            59,",
    "            61,",
    "            67,",
    "            71,",
    "            73,",
    "            79,",
    "            83,",
    "            89,",
    "            97,",
    "            101,",
    "            103,",
    "            107,",
    "            109,",
    "            113,",
    "            127,",
    "            131,",
    "            137,",
    "            139,",
    "            149,",
    "            151,",
    "            157,",
    "            163,",
    "            167,",
    "            173,",
    "            179,",
    "            181,",
    "            191,",
    "            193,",
    "            197,",
    "            199,",
    "        ]",
    "",
    "        p10 = [",
    "            1,",
    "            10,",
    "            100,",
    "            1000,",
    "            10000,",
    "            100000,",
    "            1000000,",
    "            10000000,",
    "            100000000,",
    "            1000000000,",
    "            10000000000,",
    "            100000000000,",
    "            1000000000000,",
    "            10000000000000,",
    "            100000000000000,",
    "            1000000000000000,",
    "            10000000000000000,",
    "        ]",
    "",
    "        class PrefixSum:",
    "            def __init__(self, a, n):",
    "                self.a, self.n = a, n",
    "                self.arr = [0] * n",
    "                for i in range(1, n + 1):",
    "                    self.arr[i] = self.arr[i - 1] + a[i]",
    "",
    "            def ret(self):",
    "                return self.arr",
    "",
    "            def psum(self, i):",
    "                return self.arr[i]",
    "",
    "            def rsum(self, L, R):",
    "                return self.arr[R] if L == 0 else self.arr[R] - self.arr[L - 1]",
    "",
    "            def xsum(self, x):",
    "                cnt = {0: 1}",
    "                res = 0",
    "                for i in self.arr:",
    "                    tg = i - x",
    "                    if tg in cnt:",
    "                        res += cnt[tg]",
    "                    cnt[i] = cnt.get(i, 0) + 1",
    "                return res",
    "",
    "            def pxor(self):",
    "                p = [0] * self.n",
    "                for i in range(self.n):",
    "                    p[i] = p[i - 1] ^ self.a[i]",
    "                return p",
    "",
    "        class logix(PrefixSum):",
    "            def __init__(self):",
    "                self.a, self.n = super().a, super().n",
    "                self.p = p = [[0] * 30 for _ in range(self.n)]",
    "                for i in range(30):",
    "                    for j in range(1, super().n + 1):",
    "                        p[i][j] = p[i][j - 1] + ((self.a[j] >> i) & 1)",
    "",
    "            def AND(self, L, R):",
    "                res = 0",
    "                for i in range(30):",
    "                    if self.p[i][R] - self.p[i][L - 1] == R - L + 1:",
    "                        res += 1 << i",
    "                return res",
    "",
    "            def OR(self, L, R):",
    "                res = 0",
    "                for i in range(30):",
    "                    if self.p[i][R] - self.p[i][L - 1] > 0:",
    "                        res += 1 << i",
    "                return res",
    "",
    "        def ncr(n, r, p=mod):",
    "            \"\"\"",
    "            Computes nCr % p using Fermat's Little Theorem.",
    "            Assumes p is prime and n < p.",
    "            \"\"\"",
    "            if r < 0 or r > n:",
    "                return 0",
    "            if r == 0 or r == n:",
    "                return 1",
    "            if r > n // 2:",
    "                r = n - r",
    "",
    "            num = 1",
    "            den = 1",
    "            for i in range(r):",
    "                num = (num * (n - i)) % p",
    "                den = (den * (i + 1)) % p",
    "",
    "            return (num * pow(den, p - 2, p)) % p",
    "",
    "        def lcs(n, r, p):",
    "            \"\"\"",
    "            Computes nCr % p where n >= p using Lucas' Theorem.",
    "            \"\"\"",
    "            if r == 0:",
    "                return 1",
    "            return (lcs(n // p, r // p, p) * ncr(n % p, r % p, p)) % p",
    "",
    "        def hp(n, p):",
    "            \"\"\"",
    "            Returns the exponent of the highest power of prime p dividing n!.",
    "            \"\"\"",
    "            ct = 0",
    "            while n > 0:",
    "                ct += n // p",
    "                n //= p",
    "            return ct",
    "",
    "        def kmr(n, r, p):",
    "            \"\"\"",
    "            Returns the exponent of the highest power of prime p dividing nCr.",
    "            Equivalent to the number of crs when adding r and (n-r) in base p.",
    "            \"\"\"",
    "            d = n - r",
    "            crs = 0",
    "            cry = 0",
    "",
    "            while r > 0 or d > 0 or cry > 0:",
    "                vr = r % p",
    "                vd = d % p",
    "",
    "                if vr + vd + cry >= p:",
    "                    crs += 1",
    "                    cry = 1",
    "                else:",
    "                    cry = 0",
    "",
    "                r //= p",
    "                d //= p",
    "",
    "            return crs",
    "",
    "        def crt(rem, md):",
    "            \"\"\"",
    "            Solves x = a_i (mod m_i).",
    "            Returns x mod m, where m = product(md).",
    "            \"\"\"",
    "            m = 1",
    "            for m in md:",
    "                m *= m",
    "",
    "            res = 0",
    "            for r, m in zip(rem, md):",
    "                mi = m // m",
    "                y = pow(mi, m - 2, m) if nprime(m) else pow(mi, -1, m)",
    "                res = (res + r * mi * y) % m",
    "",
    "            return res",
    "",
    "        class Combinatorics:",
    "            \"\"\"",
    "            High frequency queries",
    "            \"\"\"",
    "",
    "            def __init__(self, n, m=mod):",
    "                self.n = n",
    "                self.m = m",
    "                self.fact = [1] * (n + 1)",
    "                self.inv = [1] * (n + 1)",
    "",
    "                for i in range(1, n + 1):",
    "                    self.fact[i] = (self.fact[i - 1] * i) % m",
    "",
    "                self.inv[n] = pow(self.fact[n], m - 2, m)",
    "                for i in range(n - 1, -1, -1):",
    "                    self.inv[i] = (self.inv[i + 1] * (i + 1)) % m",
    "",
    "            def ncr(self, n, r):",
    "                if r < 0 or r > n:",
    "                    return 0",
    "                num = self.fact[n]",
    "                den = (self.inv[r] * self.inv[n - r]) % self.m",
    "                return (num * den) % self.m",
    "",
    "            def npr(self, n, r):",
    "                if r < 0 or r > n:",
    "                    return 0",
    "                return (self.fact[n] * self.inv[n - r]) % self.m",
    "",
    "    if packages:",
    "        import bisect as bs",
    "        import cmath",
    "        import os",
    "        import random",
    "        from collections import Counter as ctr",
    "        from collections import defaultdict as dd",
    "        from collections import deque as dq",
    "        from copy import deepcopy",
    "        from functools import (",
    "            cmp_to_key,",
    "            lru_cache,",
    "            reduce,",
    "        )",
    "        from heapq import heapify as hpfy",
    "        from heapq import heappop as hpop",
    "        from heapq import heappush as hpsh",
    "        from heapq import (",
    "            heappushpop,",
    "            merge,",
    "            nlargest,",
    "            nsmallest,",
    "        )",
    "        from heapq import heapreplace as hrep",
    "        from io import BytesIO, IOBase",
    "        from itertools import (",
    "            accumulate,",
    "            combinations,",
    "            count,",
    "            permutations,",
    "            product,",
    "        )",
    "        from operator import itemgetter",
    "        from string import ascii_letters as a_al",
    "        from string import ascii_lowercase as a_lc",
    "        from string import ascii_uppercase as a_uc",
    "",
    "        try:",
    "            from sortedcontainers import SortedDict as sd",
    "            from sortedcontainers import SortedList as sl",
    "            from sortedcontainers import SortedSet as ss",
    "        except ImportError:",
    "            pass",
    "",
    "        BUFSIZE = 4096",
    "",
    "    if search_sort:",
    "",
    "        def bin_search(arr, tg, lo=0, hi=None):",
    "            left, right = lo, hi or len(arr) - 1",
    "            while left <= right:",
    "                mid = left + (right - left) // 2",
    "                if arr[mid] == tg:",
    "                    return mid",
    "                elif arr[mid] < tg:",
    "                    left = mid + 1",
    "                else:",
    "                    right = mid - 1",
    "            return -1",
    "",
    "        def lower_bound(arr, tg):",
    "            left, right = 0, len(arr)",
    "            while left < right:",
    "                mid = left + (right - left) // 2",
    "                if arr[mid] < tg:",
    "                    left = mid + 1",
    "                else:",
    "                    right = mid",
    "            return left",
    "",
    "        def csort(L):",
    "            if len(L) < 2:",
    "                return L",
    "",
    "            top = max(L)",
    "            bot = min(L)",
    "            new = []",
    "            ct = [0] * (top - bot + 1)",
    "",
    "            for num in L:",
    "                ct[num - bot] += 1",
    "            for n, c in enumerate(ct):",
    "                new.extend([n + bot] * c)",
    "            return new",
    "",
    "        def merge_sub(arr, temp, l, mid, r):",
    "            for idx in range(l, r + 1):",
    "                temp[idx] = arr[idx]",
    "",
    "            i = k = l",
    "            j = mid + 1",
    "",
    "            while i <= mid and j <= r:",
    "                if temp[i] <= temp[j]:",
    "                    arr[k] = temp[i]",
    "                    i += 1",
    "                else:",
    "                    arr[k] = temp[j]",
    "                    j += 1",
    "                k += 1",
    "",
    "            while i <= mid:",
    "                arr[k] = temp[i]",
    "                i += 1",
    "                k += 1",
    "",
    "            while j <= r:",
    "                arr[k] = temp[j]",
    "                j += 1",
    "                k += 1",
    "",
    "        def msort(L, n):",
    "            temp = [0] * n",
    "            sz = 1",
    "            while sz < n:",
    "                l = 0",
    "                while l < n - 1:",
    "                    mid = min(l + sz - 1, n - 1)",
    "                    r = min(l + 2 * sz - 1, n - 1)",
    "                    merge_sub(L, temp, l, mid, r)",
    "                    l += 2 * sz",
    "                sz *= 2",
    "            return L",
    "",
    "        def rbk(text, pattern):",
    "            \"\"\"",
    "            Rabin-Karp algorithm with a rolling hash... O(n*m) worst case",
    "            \"\"\"",
    "            n = len(text)",
    "            m = len(pattern)",
    "",
    "            if m > n:",
    "                return -1",
    "",
    "            mod = 10**9 + 7",
    "            base = 256",
    "            h_pow = pow(base, m - 1, mod)",
    "",
    "            hash_pattern = 0",
    "            hash_text = 0",
    "",
    "            for i in range(m):",
    "                hash_pattern = (hash_pattern * base + ord(pattern[i])) % mod",
    "                hash_text = (hash_text * base + ord(text[i])) % mod",
    "",
    "            for i in range(n - m + 1):",
    "                if hash_text == hash_pattern:",
    "                    if text[i : i + m] == pattern:",
    "                        return i",
    "",
    "                if i < n - m:",
    "                    hash_text = (hash_text - ord(text[i]) * h_pow) % mod",
    "                    hash_text = (hash_text * base) % mod",
    "                    hash_text = (hash_text + ord(text[i + m])) % mod",
    "",
    "                    if hash_text < 0:",
    "                        hash_text += mod",
    "",
    "            return -1",
    "",
    "        def kmp(text, pattern):",
    "            \"\"\"",
    "            Knuth-Morris-Pratt algorithm with no backtracks... O(n + m) all case",
    "            \"\"\"",
    "            n = len(text)",
    "            m = len(pattern)",
    "",
    "            if not m:",
    "                return 0",
    "            if m > n:",
    "                return -1",
    "",
    "            lps = [0] * m",
    "            hash_length = 0",
    "            i = 1",
    "",
    "            while i < m:",
    "                if pattern[i] == pattern[hash_length]:",
    "                    hash_length += 1",
    "                    lps[i] = hash_length",
    "                    i += 1",
    "                else:",
    "                    if hash_length:",
    "                        hash_length = lps[hash_length - 1]",
    "                    else:",
    "                        lps[i] = 0",
    "                        i += 1",
    "",
    "            i = 0",
    "            j = 0",
    "",
    "            while i < n:",
    "                if pattern[j] == text[i]:",
    "                    i += 1",
    "                    j += 1",
    "",
    "                if j == m:",
    "                    return i - j",
    "",
    "                elif i < n and pattern[j] != text[i]:",
    "                    if j:",
    "                        j = lps[j - 1]",
    "                    else:",
    "                        i += 1",
    "",
    "            return -1",
    "",
    "        # def compute_z_array(s):",
    "        #     n = len(s)",
    "        #     z = [0] * n",
    "        #     z[0] = n",
    "        #     l, r = 0, 0",
    "",
    "        #     for i in range(1, n):",
    "        #         if i > r:",
    "        #             l, r = i, i",
    "        #             while r < n and s[r - l] == s[r]:",
    "        #                 r += 1",
    "        #             z[i] = r - l",
    "        #             r -= 1",
    "        #         else:",
    "        #             k = i - l",
    "        #             if z[k] < r - i + 1:",
    "        #                 z[i] = z[k]",
    "        #             else:",
    "        #                 l = i",
    "        #                 while r < n and s[r - l] == s[r]:",
    "        #                     r += 1",
    "        #                 z[i] = r - l",
    "        #                 r -= 1",
    "",
    "        #     return z",
    "",
    "        def Z(text, pattern):",
    "            combined = pattern + \"#\" + text",
    "            # z = compute_z_array(combined)",
    "            n = len(combined)",
    "            z = [0] * n",
    "            z[0] = n",
    "            l, r = 0, 0",
    "",
    "            for i in range(1, n):",
    "                if i > r:",
    "                    l, r = i, i",
    "                    while r < n and combined[r - l] == combined[r]:",
    "                        r += 1",
    "                    z[i] = r - l",
    "                    r -= 1",
    "                else:",
    "                    k = i - l",
    "                    if z[k] < r - i + 1:",
    "                        z[i] = z[k]",
    "                    else:",
    "                        l = i",
    "                        while r < n and combined[r - l] == combined[r]:",
    "                            r += 1",
    "                        z[i] = r - l",
    "                        r -= 1",
    "            pattern_len = len(pattern)",
    "",
    "            occurrences = []",
    "            for i in range(pattern_len + 1, len(combined)):",
    "                if z[i] == pattern_len:",
    "                    occurrences.append(i - pattern_len - 1)",
    "",
    "            return occurrences",
    "",
    "    if out_tog:",
    "        import os",
    "        from io import BytesIO, IOBase",
    "",
    "        class FastIO(IOBase):",
    "            newlines = 0",
    "",
    "            def __init__(self, file):",
    "                self._fd = file.fileno()",
    "                self.buffer = BytesIO()",
    "                self.writable = \"x\" in file.mode or \"r\" not in file.mode",
    "                self.write = self.buffer.write if self.writable else None",
    "",
    "            def read(self):",
    "                while True:",
    "                    b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
    "                    if not b:",
    "                        break",
    "                    ptr = self.buffer.tell()",
    "                    self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
    "                self.newlines = 0",
    "                return self.buffer.read()",
    "",
    "            def readline(self, size: int | None = -1):",
    "                while self.newlines == 0:",
    "                    b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
    "                    self.newlines = b.count(b\"\\n\") + (not b)",
    "                    ptr = self.buffer.tell()",
    "                    self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
    "                self.newlines -= 1",
    "                return self.buffer.readline()",
    "",
    "            def flush(self):",
    "                if self.writable:",
    "                    os.write(self._fd, self.buffer.getvalue())",
    "                    self.buffer.truncate(0), self.buffer.seek(0)",
    "",
    "        class IOWrapper(IOBase):",
    "            def __init__(self, file):",
    "                self.buffer = FastIO(file)",
    "                self.flush = self.buffer.flush",
    "                self.writable = self.buffer.writable",
    "                self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))",
    "                self.read = lambda: self.buffer.read().decode(\"ascii\")",
    "                self.readline = lambda: self.buffer.readline().decode(\"ascii\")",
    "",
    "        sys.stdout = IOWrapper(sys.stdout)",
    "",
    "    if graph:",
    "        from types import GeneratorType",
    "",
    "        def bootstrap(f, stk=[]):",
    "            def wrappedfunc(*args, **kwargs):",
    "                if stk:",
    "                    return f(*args, **kwargs)",
    "                else:",
    "                    to = f(*args, **kwargs)",
    "                    while True:",
    "                        if type(to) is GeneratorType:",
    "                            stk.append(to)",
    "                            to = next(to)",
    "                        else:",
    "                            stk.pop()",
    "                            if not stk:",
    "                                break",
    "                            to = stk[-1].send(to)",
    "                    return to",
    "",
    "            return wrappedfunc",
    "",
    "        # # Faster to use lol or dd for C* fast implementation for smaller lists",
    "        # class lst_lst:",
    "        #     def __init__(self, n):",
    "        #         self.n = n",
    "        #         self.pre = []",
    "        #         self.curr = []",
    "        #         self.notest = [-1] * (n + 1)",
    "",
    "        #     def append(self, i, j):",
    "        #         self.pre.append(self.notest[i])",
    "        #         self.notest[i] = len(self.curr)",
    "        #         self.curr.append(j)",
    "",
    "        #     def iterate(self, i):",
    "        #         tmp = self.notest[i]",
    "        #         while tmp != -1:",
    "        #             yield self.curr[tmp]",
    "        #             tmp = self.pre[tmp]",
    "",
    "        class FenwickTree:",
    "            def __init__(self, size_or_list):",
    "                if isinstance(size_or_list, int):",
    "                    self.n = size_or_list",
    "                    self.tree = [0] * (self.n + 1)",
    "                else:",
    "                    self.n = len(size_or_list)",
    "                    self.tree = [0] * (self.n + 1)",
    "                    for i in range(self.n):",
    "                        self._add(i + 1, size_or_list[i])",
    "",
    "            def _add(self, i, delta):",
    "                while i <= self.n:",
    "                    self.tree[i] += delta",
    "                    i += i & (-i)",
    "",
    "            def _query(self, i):",
    "                s = 0",
    "                while i > 0:",
    "                    s += self.tree[i]",
    "                    i -= i & (-i)",
    "                return s",
    "",
    "            def update(self, i, delta):",
    "                self._add(i + 1, delta)",
    "",
    "            def query(self, i):",
    "                return self._query(i + 1)",
    "",
    "            def range_query(self, l, r):",
    "                return self._query(r + 1) - self._query(l)",
    "",
    "        class SegmentTree:",
    "            def __init__(self, arr, merge_func, identity_val):",
    "                self.n = len(arr)",
    "                self.merge = merge_func",
    "                self.identity = identity_val",
    "                self.tree = [self.identity] * (2 * self.n)",
    "                for i in range(self.n):",
    "                    self.tree[self.n + i] = arr[i]",
    "                self._build()",
    "",
    "            def _build(self):",
    "                for i in range(self.n - 1, 0, -1):",
    "                    self.tree[i] = self.merge(self.tree[2 * i], self.tree[2 * i + 1])",
    "",
    "            def update(self, pos, new_val):",
    "                pos += self.n",
    "                self.tree[pos] = new_val",
    "                while pos > 1:",
    "                    if pos % 2 == 0:",
    "                        self.tree[pos // 2] = self.merge(",
    "                            self.tree[pos], self.tree[pos + 1]",
    "                        )",
    "                    else:",
    "                        self.tree[pos // 2] = self.merge(",
    "                            self.tree[pos - 1], self.tree[pos]",
    "                        )",
    "                    pos //= 2",
    "",
    "            def query(self, l, r):",
    "                res_left = self.identity",
    "                res_right = self.identity",
    "                l += self.n",
    "                r += self.n + 1",
    "                while l < r:",
    "                    if l % 2 == 1:",
    "                        res_left = self.merge(res_left, self.tree[l])",
    "                        l += 1",
    "                    if r % 2 == 1:",
    "                        r -= 1",
    "                        res_right = self.merge(self.tree[r], res_right)",
    "                    l //= 2",
    "                    r //= 2",
    "                return self.merge(res_left, res_right)",
    "",
    "        def bfs(graph, start_node, n):",
    "            from collections import deque",
    "",
    "            dist = [inf] * n",
    "            dist[start_node] = 0",
    "            q = deque([start_node])",
    "            while q:",
    "                u = q.popleft()",
    "                for v in graph[u]:",
    "                    if dist[v] == inf:",
    "                        dist[v] = dist[u] + 1",
    "                        q.append(v)",
    "            return dist",
    "",
    "        def dfs(graph, start_node, n):",
    "            visited = set()",
    "            stack = [start_node]",
    "            while stack:",
    "                u = stack.pop()",
    "                if u not in visited:",
    "                    visited.add(u)",
    "                    for v in reversed(graph[u]):",
    "                        if v not in visited:",
    "                            stack.append(v)",
    "            return visited",
    "",
    "        def djk(graph, start_node, n):",
    "            import heapq",
    "",
    "            dist = {i: inf for i in range(n)}",
    "            dist[start_node] = 0",
    "            pq = [(0, start_node)]",
    "            while pq:",
    "                d, u = heapq.heappop(pq)",
    "                if d > dist[u]:",
    "                    continue",
    "                for v, weight in graph[u]:",
    "                    if dist[u] + weight < dist[v]:",
    "                        dist[v] = dist[u] + weight",
    "                        heapq.heappush(pq, (dist[v], v))",
    "            return dist",
    "",
    "    if hashing:",
    "        import random",
    "",
    "        RANDOm = random.getrandbits(20)",
    "",
    "        class Hrap(int):",
    "            def __init__(self, x):",
    "                int.__init__(x)",
    "",
    "            def __hash__(self):",
    "                return super(Hrap, self).__hash__() ^ RANDOm",
    "",
    "    if rof:",
    "        file = open(\"input.txt\", \"r\").readline().strip()[1:-1]",
    "        fin = open(file, \"r\")",
    "",
    "        def input():",
    "            return fin.readline().strip()",
    "",
    "        output_file = open(\"output.txt\", \"w\")",
    "",
    "        def fprint(*args, **kwargs):",
    "            print(*args, **kwargs, file=output_file)",
    "",
    "    if de:",
    "",
    "        def debug(*args, **kwargs):",
    "            print(\"\\033[92m\", end=\"\")",
    "            print(*args, **kwargs)",
    "            print(\"\\033[0m\", end=\"\")",
    "",
    "",
    "def solve():",
    "    # global f, op",
    "",
    "    pass",
    "",
    "",
    "def main():",
    "    # solve()",
    "",
    "    for _ in range(II()):",
    "        solve()",
    "",
    "    # res: list[str] = [solve() for _ in range(II())]",
    "    # printf(res)",
    "",
    "    # iris: list[int] = [solve() for _ in range(II())]",
    "    # iprint(iris)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()",
    "",
    "    # with open(\"input.txt\", \"r\") as f:",
    "    #     op = open(\"output.txt\", \"w\")",
    "    #     if \"II\" in globals():",
    "    #         for _ in range(II()):",
    "    #             solve()",
    "    #     else:",
    "    #         for _ in range(int(input())):",
    "    #             solve()"
]